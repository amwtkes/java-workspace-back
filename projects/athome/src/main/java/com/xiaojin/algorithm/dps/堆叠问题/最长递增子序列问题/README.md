最长递增子序列长度：
> 3,2,1,2,3,0,4,6,2,7
> 
- dp[i]的含义是以第i个元素结尾的子串中最长递增子序列长度
- dp[i] = max{dp[0->i-1]+1 当且仅当 a[k]<a[i]} 比如例子：{4,1,3,2,3,9,5,6}
- dp[]={1,1,2,2,3,4,4,5}
- dp[开头的例子]={1,1,1,2,3,1,4,5,2,6}
- 所以O(n^2)-因为每次求dp[i]的时候要遍历0->i-1的索引。
- 引入end[i]数组，时间复杂度可以降到O(nlgn).
- end[i]的含义是：长度为i+1的子串中，最小的结尾数。对于开头的例子：
  - end[0] = 3(长度为1的子串中，最小的结尾数是3，肯定啊，因为只有3一个元素)；
  - 因为a[1]<a[0]所以不能更新end[1]，因为dp[1]==dp[0]==1，但是因为a[1]<a[0]所以长度为1的子序列中最小的结尾数要更新为a[1]
  - 所以end[0]=2
  - 更新end[i]的算法是，拿到a[x]=y,在end[0->i-1]范围中二分搜索y的位置，
    - 假设在j处找到end[j]<y, end[j+1]>y。则，end[j+1]=y。因为索引x可以形成j+2的长度，而且a[x]比end[j+1]还要小，所以更新end[j+1]=y.
    - 如果没有比自己大的，也就是y是end[]中最大的，则end[i+1]=y。
    - 如果没有比自己小的，也就是y是end[]中最小的，则end[0]=y。
  - end[]={0,2,3,4,6,7}
  - end的特点
    - 顺序性，没有顺序性，end函数没有意义，因为，子序列增长是由方向性的；如果没方向性，就跟排序是一个问题了；
    - 扩展性跟值有关。为什么是记录最小的最后元素？
      - 因为我们求最长
      - 在顺序向右遍历的时候，对于长度为i的子序列要扩展成i+1的可能性中
      - 假设有x条这样的递增子序列，那么肯定是最后一个元素最下的最有可能扩展成功！所以取最小。
      - 即便可能有一些i长度的子序列也可以扩展成功，但是长度不会超过最小元素的扩展。[看这个证明](https://app.yinxiang.com/shard/s65/nl/15273355/cc8d4888-76e9-41e5-a0bc-ce8dc68deffc/)
      - 这个特点跟贪心算法有联系，具体还没有分析。
  - [左解析](https://www.mashibing.com/study?courseNo=465&sectionNo=57231&systemId=21)
