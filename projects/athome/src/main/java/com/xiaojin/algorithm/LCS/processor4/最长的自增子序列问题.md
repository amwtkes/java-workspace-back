#注意这里是自增就行，不要求连续。
对于这个串来说`7,1,4,3,5,5,9,4,10,25,11,12,33,2,13,6`子串
`1,3,4,10,11,12,13`就是一个解。
这个问题就变成了求这个自增序列的最长有多长，序列的index是什么。

## DP可以解答
可以用`红绿灯`法来做
- 因为不要求连续，所以不能用`包含-向前的方法`
- 用`可选`范围来做递归子。
###解题：
1. 从后向前递归
2. 函数f(i,m)- i表示可选的index范围是`[0,i]`. m-表示当前这个状态下，也就是可选的index是[0,i]的时候，下一个可选的值的最大值是`m`
3. m初始化可以是Int.maxValue,表示后面还没有选值
4. i=n 初始第一个循环,f(n,Int.maxValue) = max{f(n-1,a[n])+1,f(n-1,Int.maxValue)}
5. i<n max不是最大值:f(n-1,a[n])
   1. if a[n-1]>a[n]  f(n-1,a[n]) = max{f(n-1,Int.maxValue) `丢弃掉前面的选择a[n]，从a[n-1]重新开始`, f(n-2,a[n]) `丢弃掉a[n-1]`}
   2. if a[n-1]<=a[n] f(n-1,a[n])= max{f(n-2,a[n-1])+1 `(选了a[n-1])`,f(n-2,a[n]) `任然不选a[n-1]，可能a[n-1]过小`} //为什么没有f(n-1,Int.maxvalue)？因为，f(n-1,Int.maxValue)肯定比f(n-1,a[n])要小

