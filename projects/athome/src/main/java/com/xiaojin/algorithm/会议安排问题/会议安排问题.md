> 每个会议给定开始与结束时间，后面的会议如果跟前面的有冲突，则完全取消前面的，保留后面的。给定一个会议的数组，返回最后的会议列表
> 
> 如：[1,3],[2,4],[4,6]
> 
> out:[2,4],[4,6]
> 
> 如果再次输入[3,5]
> 
> out:[3,5]


### 解答
> [2,9],[13,27],[56,59],[2,17]
> 
> out:[2,17],[56,59]
1. 堆解法
   1. 将所有的会议的开始、结束时间单独拎出来，排序。[2(1),2(4),9(1),13(2),17(4),27(2),56(3),59(3)]并记录分别属于第几个会议。(nlogn)
   2. 从[0-n]依次遍历整个队列，并准备一个容器用于存放已经开始但是还没结束的会议。如：当遍历到`2(1)`这个元素，查看容器中是否有`1`这个会议，如果没有说明是第一次进入容器，是容器开头，就加入到容器；相反，如果存在，说明是会议的结尾，就要做合并。容器中已经存在那些会议都跟这个要弹出的会议冲突了，那么弹出最大的`会议号`；那么合并的结果就是这个最大的会议号的时间段。
   3. 合并的结果就是容器中只剩下这个最大会议号的会议了。同时，将合并删除的那些会议号放入已合并的`队列`中，因为，这些删除的会议并没有遇到自己的结束时间，所以当往后遇到结束时间时，发现在已删除的队列中，则pass掉。
   4. 例如：m1=[2,5],m2=[4,6],m3=[3,10],m4=[10,12]
   5. 排序：[2[m1],3[m3],4[m2],5[m1],6[m2],10[m4],10[m3],12[m4]]。可以看到这里有个问题，就是m4与m3可以共存，如果用上面的算法，则m3被m4覆盖，因为排序可能是不稳定的，所以，还要加一个判断，如果要合并的时候，容器中的元素还剩下[m3,m4]这时遇到了m3的结束元素`10[m3]`，还要判断容器中最大的会议号，此时是m4，的起始时间是否跟m3的结束时间相等，如果相等就放入`已保留`队列，否则进入`已删除`队列。
   6. ``突然发现！！！``**堆解法的一个漏洞**。在判断m3=[1，3]，m2=[2,5],m1=[4,6]这时结果应该是m1被m2遮住，取m2;m2被m3遮住，取m3，最后答案是m3；但是堆解法：
   7. 1(m3)入队列，m2入队列，3(m3)出队，这时队列中经过合并以后，只剩下m3.因为m3与m1没有交集，最后结果是m1与m3.实际出错。
2. 线段树解法
   1. [左讲解](https://ke.qq.com/webcourse/index.html#cid=4122671&term_id=104714709&taid=13021404542724143&type=1024&vid=387702298773008545)
   2. 构造线段树，然后从后往前遍历所有的会议，然后更新线段树。时间复杂度是O(nlogn).
